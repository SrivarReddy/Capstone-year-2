# -*- coding: utf-8 -*-
"""Copy of Capstone Year2 2025.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bV9LdAvuhNoWxhCFMhaQJCB2F6yPwZRF
"""

import os
import firebase_admin
from firebase_admin import credentials, firestore
import streamlit as st
import googlemaps
from dotenv import load_dotenv
from langchain_core.messages import AIMessage, HumanMessage
from langchain_community.llms import HuggingFaceEndpoint
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate

# Load environment variables
load_dotenv()
API_KEY = "AIzaSyD7rN_0DmECirRm_7XwEdv4t_1pAGwf494"
HF_API_TOKEN = os.getenv("HF_API_TOKEN")  # Store your Hugging Face API key in a .env file

# Initialize Firebase
if not firebase_admin._apps:
    cred = credentials.Certificate("serviceAccountKey.json")
    firebase_admin.initialize_app(cred)
db = firestore.client()

# Initialize Google Maps API
gmaps = googlemaps.Client(key=API_KEY)

# Initialize Hugging Face Model
repo_id = "mistralai/Mixtral-8x7B-Instruct-v0.1"
task = "text-generation"

# App Config
st.set_page_config(page_title="YatriBot", page_icon="üåç")
st.title("YatriBot ‚úàÔ∏è")

# Sidebar Menu
st.sidebar.title("üåç Explore Cities with YatriBot")
menu = st.sidebar.radio("Select an Option:", ["Chatbot", "City Explorer", "Leaderboard"])

# ‚úÖ CHATBOT FUNCTIONALITY ‚úÖ
if menu == "Chatbot":
    # Define Chatbot Template
    template = """
    You are a travel assistant chatbot named YatriBot.AI. Help users with:
    - Booking Flights, Hotels, and Rental Cars
    - Providing Destination Information & Local Attractions
    - Travel Tips & Weather Updates
    - Customer Support for bookings & issues

    Chat history:
    {chat_history}

    User question:
    {user_question}
    """
    prompt = ChatPromptTemplate.from_template(template)


    def get_response(user_query, chat_history):
        llm = HuggingFaceEndpoint(
            huggingfacehub_api_token=HF_API_TOKEN,
            repo_id=repo_id,
            task=task
        )
        chain = prompt | llm | StrOutputParser()
        response = chain.invoke({
            "chat_history": chat_history,
            "user_question": user_query,
        })
        return response.replace("AI response:", "").strip()


    # Session state for chat history
    if "chat_history" not in st.session_state:
        st.session_state.chat_history = [
            AIMessage(content="Hello! I am YatriBot. How can I assist you?")
        ]

    # Display chat history
    for message in st.session_state.chat_history:
        role = "AI" if isinstance(message, AIMessage) else "Human"
        with st.chat_message(role):
            st.write(message.content)

    # User Input
    user_query = st.chat_input("Type your message here...")
    if user_query:
        st.session_state.chat_history.append(HumanMessage(content=user_query))
        with st.chat_message("Human"):
            st.markdown(user_query)

        response = get_response(user_query, st.session_state.chat_history)
        with st.chat_message("AI"):
            st.write(response)

        st.session_state.chat_history.append(AIMessage(content=response))

# ‚úÖ CITY EXPLORER FUNCTIONALITY ‚úÖ
elif menu == "City Explorer":
    city = st.text_input("Enter your city:")

    if st.button("Find Landmarks") or st.session_state.get("quiz_started", False):
        st.session_state.quiz_started = True
        quiz_questions = {
            "Paris": [
                {"question": "What is the height of the Eiffel Tower?", "options": ["324m", "280m", "500m"],
                 "answer": "324m"},
                {"question": "Which museum houses the Mona Lisa?", "options": ["Louvre", "Orsay", "Pompidou"],
                 "answer": "Louvre"}
            ],
            "New York": [
                {"question": "What is the name of the island where the Statue of Liberty stands?",
                 "options": ["Ellis Island", "Liberty Island", "Manhattan"], "answer": "Liberty Island"}
            ]
        }
        st.session_state.quiz_list = quiz_questions.get(city, [])
        st.session_state.user_score = 0
        st.session_state.current_question = 0

        # Fetch landmarks
        landmarks = gmaps.places_nearby(
            location=gmaps.geocode(city)[0]["geometry"]["location"],
            radius=5000,
            type="tourist_attraction"
        )
        if "results" in landmarks:
            st.write("üìç **Top 5 Landmarks:**")
            for landmark in landmarks["results"][:5]:
                st.write(f"‚Ä¢ {landmark['name']}")

        # Display quiz
        if st.session_state.quiz_list and st.session_state.current_question < len(st.session_state.quiz_list):
            q = st.session_state.quiz_list[st.session_state.current_question]
            user_answer = st.radio(
                f"Q{st.session_state.current_question + 1}: {q['question']}",
                q["options"],
                key=f"quiz_{city}_{st.session_state.current_question}"
            )

            if st.button("Submit Answer"):
                if user_answer == q["answer"]:
                    st.success("‚úÖ Correct! +10 points")
                    st.session_state.user_score += 10
                else:
                    st.error(f"‚ùå Incorrect! The correct answer is {q['answer']}.")

                st.session_state.current_question += 1

                if st.session_state.current_question >= len(st.session_state.quiz_list):
                    user_id = "test_user"
                    user_ref = db.collection("users").document(user_id)
                    user_ref.set({"score": firestore.Increment(st.session_state.user_score)}, merge=True)
                    st.success(f"üéâ **Quiz Complete! Your total score: {st.session_state.user_score} points**")
                    st.session_state.quiz_started = False

# ‚úÖ LEADERBOARD FUNCTIONALITY ‚úÖ
elif menu == "Leaderboard":
    users_ref = db.collection("users").order_by("score", direction=firestore.Query.DESCENDING)
    users = users_ref.stream()
    st.subheader("üèÜ **Leaderboard** üèÜ")
    for i, user in enumerate(users):
        user_data = user.to_dict()
        st.write(f"{i + 1}. {user.id} - {user_data['score']} Points")